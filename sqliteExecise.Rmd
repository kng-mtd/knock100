---
title: "SQLite exercise"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: show 
---

```{r setup, include=FALSE}
library(DBI)
library(RSQLite)
library(tidyverse)
library(palmerpenguins)


con=dbConnect(SQLite(), ":memory:")
# or
#con=dbConnect(SQLite(), "database.sqlite")

knitr::opts_chunk$set(echo=T,warning=F,message=F,comment='',
                      connection = "con")
```

## R process to SQLite
```{r}
tb=tibble(
  col1=c('a','b','c','d'),col2=c(1,2,3,4),col3=c(10,20,30,40)
)
dbWriteTable(con,'table0',tb)
dbReadTable(con,'table0')
```

```{r}
dbWriteTable(con,'table0',tb,append=T,row.names=F)
dbReadTable(con,'table0')
dbRemoveTable(con,'table0')
```

```{r}
dbWriteTable(con,'penguin',penguins)
dbGetQuery(con,'select * from penguin limit 5;')
```

```{sql}
select * from penguin limit 5;
```

```{sql}
drop table penguin;
```


## R create SQLite table
```{r}
dbExecute(con,
          "create table table1 (chr1 text, chr2 text, num1 int, num2 int, num3 real, day text)")

dbExecute(con,
          "insert into table1 (chr1, chr2, num1, num2, num3, day) values 
          ('a','c1',1,10,0.5,'2000-01-01'),
          ('b','c1',2,20,0.33,'2000-02-01'),
          ('c','c2',3,30,0.25,'2000-03-01')")
```
```{sql}
select * from table1;
```
```{sql}
drop table table1;
```

## create table by vanilla SQLite
### master table: table0
```{sql}
create table table0 (chr1 text, num1 int, num2 real);
```
```{sql}
insert into table0 (chr1, num1, num2) values
  ('a',100,1.0), ('b',200,0.5), ('c',300,0.33), ('d',400,0.25), ('e',500,0.2);
```
```{sql}
select * from table0;
```

### transaction table: table1
```{sql}
create table table1 (chr1 text, chr2 text, num1 int, num2 int, num3 real, day text);
```
```{sql}
insert into table1 (chr1, chr2, num1, num2, num3, day) values
  ('a','c1',1,10,0.5,'2000-01-01'),
  ('b','c1',2,20,0.33,'2000-02-01'),
  ('c','c2',3,30,0.25,'2000-03-01');
```
```{sql}
select * from table1;
```

```{sql}
delete from table1;
```


## create table by R
```{r}
x1=sample(c('a','b','c','d'),100,replace=T,prob=c(0.6,0.3,0.15,0.05))
x2=sample(c('c1','c2'),100,replace=T,prob=c(0.7,0.3))
x3=floor(runif(100,0,10))
x4=floor(runif(100,0,100))
x5=runif(100,0,1)

date_seq=seq.Date(as.Date('2020-01-01'),as.Date('2021-12-31'),by='day')
x6=sample(date_seq,100,replace=T)

sql0="insert into table1 (chr1, chr2, num1, num2, num3, day) values "
sql1=paste0("('",x1,"','",x2,"',",x3,",",x4,",",x5,",'",x6,"');")

sql=paste0(sql0,sql1)

for(i in sql) dbExecute(con,i)
```

```{sql}
select * from table1;
```


## rows in table0 exist in table1
```{sql}
select * from table0
where exists (select 1 from table1 where table0.chr1=table1.chr1);
```


## rows its col1's value is equal, col2's value is not equal
```{sql}
select distinct t1.chr1, t1.chr2
from table1 as t1 inner join table1 as t2
  on t1.chr1=t2.chr1 and t1.chr2!=t2.chr2;
```


## groups with specified column's all elements meet condition
The query retrieves all distinct values of chr1 in table1 where there are no rows in the same table (table1) for that chr1 value with num1 being less than 2.
```{sql}
select distinct chr1 from table1 as t1
where not exists(
  select 1 from table1 as t2
  where t2.chr1=t1.chr1 and t2.num1<2
);
```


## groups with specified multi columns meet each conditions
The query retrieves distinct values of chr1 from table1 where certain conditions, specified in the CASE statement, are not satisfied for any rows associated with that chr1. In other words, it returns chr1 values where no rows meet the specified criteria.
```{sql}
select distinct chr1 from table1 as t1
where not exists(
  select 1 from table1 as t2
  where t2.chr1=t1.chr1
    and 1=case when chr2='c1' and num1<2 then 1
      when chr2='c2' and num1<3 then 1
      else 0 end
);
```


## groups include all specified elements
The query finds chr2 values in table1 such that the set of chr1 values associated with them (in table1) completely covers all chr1 values from table0.\
The query retrieves distinct values of chr2 from table1 where all chr1 values from table0 are also present in a subset of rows in table1 with the same chr2.
```{sql}
select distinct chr2 from table1 as t1
where not exists(
  select chr1 from table0
  except
  select chr1 from table1 as t2
  where t2.chr2=t1.chr2
);
```



## rows in earliest or latest day
```{sql}
select chr1, chr2, min(day), max(day) from table1 group by chr1, chr2;
```

## cross aggregation by 2 categories
```{sql}
select chr1
, count(case when chr2='c1' then 1 else null end) as n_c1
, sum(case when chr2='c1' then num1 else 0 end) as sum_c1
, count(case when chr2='c2' then 1 else null end) as n_c2
, sum(case when chr2='c2' then num1 else 0 end) as sum_c2
from table1 group by chr1;
```


## proportion of each row's value 
```{sql}
select chr1, num1
, num1*1.0/sum(num1) over(partition by chr1) as prop
from table1;
```


## pairs
### duplication
```{sql}
select t1.chr1 as chr_a, t2.chr1 as chr_b
from  table0 t1 cross join table0 t2
```

### permutation
```{sql}
select t1.chr1 as chr_a, t2.chr1 as chr_b
from  table0 t1 inner join table0 t2 on t1.chr1!=t2.chr1;
```

### combination
```{sql}
select t1.chr1 as chr_a, t2.chr1 as chr_b
from  table0 t1 inner join table0 t2 on t1.chr1<t2.chr1;
```



## values of back or forward days
```{sql}
select chr1 ,day
, num1
, lag(num1,1) over(partition by chr1 order by day) as back1
, lag(num1,2) over(partition by chr1 order by day) as back2
, lead(num1,1) over(partition by chr1 order by day) as forward1
, lead(num1,2) over(partition by chr1 order by day) as forward2
from table1
where chr2='c2';
```


## cumulative, moving average
```{sql}
select day
, num1
, sum(num1) over(order by day) as acm
, sum(num1) over(order by day
  rows between 6 preceding and current row) as mv_acm
, avg(num1) over(order by day
  rows between 6 preceding and current row) as mv_avg  
from table1
where chr1='a' and chr2='c2';
```


## differnce of difference
```{sql}
with tmp1 as(
  select day
  , num1
  , num1-lag(num1,1) over(order by day) as diff
  from table1
  where chr1='a' and chr2='c2'
)
select *
, diff-lag(diff,1) over(order by day) as dofd
from tmp1;
```


## see consequtive meet conditions
```{sql}
select *
, case
  when num3>lag(num3,1) over(order by day)
    and lag(num3,1) over(order by day)>lag(num3,2) over(order by day) then 1 else null
  end as up2
from table1
order by day;
```


```{sql}
drop table table1;
```
```{sql}
drop table table0;
```


## recursive CTE

### make number sequence
```{sql}
with tmp1 as(
  select 1 as num
  union all
  select num+1 from tmp1
  where num<10
  --limit 10
)
select * from tmp1;
```

### make date sequence
```{sql}
with tmp1 as(
  select '2024-01-01' as date
  union all
  select date(julianday(date)+1) from tmp1
  where date<'2024-01-10'
)
select * from tmp1;
```

### Fibonacci sequence
```{sql}
with tmp1 as(
  select 1 as n, 0 as val, 1 as pre
  union all
  select n+1, val+pre, val
  from tmp1
  where n<10
)
select n, val from tmp1
;
```

 
### hierarchy level
```{sql}
create table table0 (id,child,parent);
```
```{sql}
insert into table0 (id,child,parent) values
(1,'a',null)
,(2,'aa','a')
,(3,'ab','a')
,(4,'ac','a')
,(5,'aaa','aa')
,(6,'aab','aa')
,(7,'aba','ab')
,(8,'abb','ab')
,(9,'aca','ac')
,(10,'acac','aca')
;
```
```{sql}
select * from table0;
```
 
```{sql}
with tmp1 as(
  select id,child as name,parent,1 as lv
  from table0
  where parent is null --parent of root is null
  union all
  select t0.id,t0.child,t0.parent,tmp1.lv+1
  from table0 as t0
  inner join tmp1 on t0.parent=tmp1.name
)
select * from tmp1;
```
 
```{sql}
drop table table0;
```

### back to root
```{sql}
create table table0 (id,name,parent);
```
```{sql}
insert into table0 (id,name,parent) values
  (1, 'Alice', NULL)
, (2, 'Bob', 1)
, (3, 'Charlie', 1)
, (4, 'David', 2)
, (5, 'Eve', 2)
, (6, 'Frank', 3)
, (7, 'Grace', 5)
;  
```
```{sql}
select * from table0;
```

```{sql}
with tmp1 as(
  select id, parent, name, 0 as era
  from table0
  where id=7 -- specify child
  union all
  select table0.id, table0.parent, table0.name, tmp1.era+1
  from table0
  inner join tmp1 on table0.id=tmp1.parent
)
select * from tmp1
order by era
;
```

```{sql}
drop table table0;
```

### count components
```{sql}
create table table0 (id,child,qty);
```
```{sql}
insert into table0 (id,child,qty) values
  ('a', 'b', 2)
, ('a', 'c', 1)
, ('b', 'd', 4)
, ('b', 'e', 2)
, ('c', 'f', 3)
, ('c', 'g', 2)
;
```
```{sql}
select * from table0;
```

```{sql}
with recursive tmp1 as (
  select id, child, qty, qty as acm
  from table0
  where id='a' -- specify parent
  union all
  select table0.id, table0.child, table0.qty
  , tmp1.acm*table0.qty as acm
  from table0
  inner join tmp1 on table0.id=tmp1.child
)
select child
, sum(acm) as total
from tmp1
group by child
;
```

```{sql}
drop table table0;
```


### minimum depth on graph
```{sql}
create table table0 (node1,node2);
```
```{sql}
insert into table0 (node1,node2) values
('a','b')
,('a','c')
,('b','d')
,('c','e')
,('c','f')
,('e','g')
,('f','h')
,('g','i')
,('i','j')
,('c','j')
;
```
```{sql}
select * from table0;
```
 
```{sql}
with tmp1 as(
  select node1,node2,1 as depth
  from table0
  where node1='a' --start node
  union all
  select t0.node1,t0.node2,tmp1.depth+1
  from table0 as t0
  inner join tmp1 on t0.node1=tmp1.node2
  where tmp1.depth<10 --max search depth
)
select node2 as goal,min(depth) as depth from tmp1
group by goal order by depth
;
```

```{sql}
drop table table0;
```

### minimum depth on graph
```{sql}
create table table0 (node1,node2,weight);
```
```{sql}
insert into table0 (node1,node2,weight) values
('a','b',1)
,('a','c',2)
,('b','d',3)
,('c','e',2)
,('c','f',1)
,('e','g',2)
,('f','h',3)
,('g','i',2)
,('i','j',1)
,('c','j',2)
;
```
```{sql}
select * from table0;
```

```{sql}
with tmp1 as(
  select node1, node2
  , weight
  , '>' as path
  from table0
  where node1='a' --start node
  union all
  select t0.node1,t0.node2
  , tmp1.weight+t0.weight
  , path||t0.node1||' >'
  from table0 as t0
  inner join tmp1 on t0.node1=tmp1.node2
  where tmp1.weight<100 --max search depth
)
select node2 as goal
, min(weight) as distance
, path||node2 as path from tmp1
group by goal order by goal
;
```

```{sql}
drop table table0;
```

### see cycle on graph
```{sql}
create table table0 (node1, node2);
```
```{sql}
insert into table0 (node1, node2) values
  ('a', 'b')
, ('b', 'c')
, ('c', 'd')
, ('d', 'b') -- cycle b >c >d >b
, ('e', 'f')
, ('f', 'g')
, ('g', 'e') -- cycle e >f >g >e
;
```
```{sql}
select * from table0;
```

```{sql}
with tmp1 as(
  select node1 ||' >'|| node2 as path
  , node2 as current
  , 1 as depth
  from table0
  union all
  select path ||' >'|| node2, node2, depth+1
  from tmp1
  inner join table0 on tmp1.current=table0.node1
  where depth<100 --less than #node
)
select path from tmp1
where path like current||' >% >'||current
  and path not like current||' >% >'||current||' >%'
;
```

```{sql}
drop table table0;
```


### split text by some characters
```{sql}
create table table0 (id,txt);
```
```{sql}
insert into table0 (id,txt) values
  (1,'abcd efgh')
, (2,'ijk lmn opq')
, (3,'rstu vwxyz')
;	
```
```{sql}
select * from table0;
```

```{sql}
with tmp1 as(
  select id, 1 as pos, substr(txt,1,2) as chrs --by 2 characters
  from table0
  union all
  select tmp1.id, pos+1, substr(table0.txt,pos+1,2) --by 2 characters
  from tmp1 join table0 on tmp1.id=table0.id
  where pos<length(table0.txt)
)
select * from tmp1
where not length(replace(chrs,' ',''))<2
order by id, pos
;
```

```{sql}
with tmp1 as(
  select id, 1 as pos, substr(txt,1,3) as chrs --by 3 characters
  from table0
  union all
  select tmp1.id, pos+1, substr(table0.txt,pos+1,3) --by 3 characters
  from tmp1 join table0 on tmp1.id=table0.id
  where pos<length(table0.txt)
)
select * from tmp1
where not length(replace(chrs,' ',''))<3
order by id, pos
;
```

```{sql}
drop table table0;
```



## matrix on SQLite
```{r}
tb1=tibble(row=c(1,1,1,2,2,2),col=c(1,2,3,1,2,3),val=c(1.0,0.0,3.0,4.0,5.0,6.0))
dbWriteTable(con,'tb1',tb1)
dbReadTable(con,'tb1')

tb2=tibble(row=c(1,1,2,2,3,3),col=c(1,2,1,2,1,2),val=c(1.0,2.0,3.0,0.0,5.0,6.0))
dbWriteTable(con,'tb2',tb2)
dbReadTable(con,'tb2')

tb3=tibble(row=c(1,1,1,2,2,3,3,3,3)
           ,col=c(1,2,3,1,2,3,1,2,3)
           ,val=c(1.0,2.0,3.0,2.0,3.0,5.0,3.0,5.0,7.0))
dbWriteTable(con,'tb3',tb3)
dbReadTable(con,'tb3')
```

```{sql}
select row,col,val from tb1 order by row,col;
```

```{sql}
create temp table tbt as
select col,row,val from tb1 order by row,col;
```
```{sql}
select col,row,val from tbt order by row,col;
```

```{sql}
drop table tbt;
```


```{sql}
select row,col,tb1.val+tb2.val
from tb1 inner join tb2 using(row,col);
```


```{sql}
create index idx1 on tb1(col);
```
```{sql}
create index idx2 on tb2(row);
```
```{sql}
select tb1.row,tb2.col,sum(tb1.val*tb2.val)
from tb1 inner join tb2 on tb1.col=tb2.row
where tb1.val!=0 and tb2.val!=0
group by tb1.row,tb2.col;
```
\
or
```{sql}
delete from tb1 where val=0;
```
```{sql}
delete from tb2 where val=0;
```

```{sql}
select tb1.row,tb2.col,sum(tb1.val*tb2.val)
from tb1 inner join tb2 on tb1.col=tb2.row
group by tb1.row,tb2.col;
```


```{r}
dbRemoveTable(con,'tb1')
dbRemoveTable(con,'tb2')
dbRemoveTable(con,'tb3')
```


## process to JSON
https://www.sqlite.org/json1.html
```{r}
dbExecute(con,
          "create temp table table1 (id int, json text)")
data=c("{'key1':1,'key2':10,'key3':{'key31':101,'key32':102,'key33':'aaa'}}",
       "{'key1':2,'key2':20,'key3':{'key31':201,'key33':'bbb'}}",
       "{'key1':3,'key3':{'key31':301,'key33':'ccc'}}")

dbExecute(con,
          paste0('insert into table1 (id, json) values ',
                 '(1,"',data[1],'"),',
                 '(2,"',data[2],'"),',
                 '(3,"',data[3],'")'))
```
read
```{sql}
select * from table1;
```
```{sql}
select id, json_extract(json, '$') as root from table1;
```
```{sql}
select id, json_extract(json, '$.key2') as key2 from table1;
```
```{sql}
select id, json_extract(json, '$.key3') as key3 from table1;
```
```{sql}
select json_extract(json, '$.key3.key31') as key31 from table1;
```
update
```{sql}
update table1 set json=json_set(json,'$.key2',30) where id=3;
```
```{sql}
select id, json_extract(json, '$.key2') as key2 from table1;
```
insert
```{sql}
update table1 set json=json_insert(json,'$.key3.key32',202) where id=2;
```
```{sql}
select id, json_extract(json, '$.key3') as key3 from table1;
```
delete
```{sql}
update table1 set json=json_remove(json,'$.key2') where id=2;
```
```{sql}
select id, json_extract(json, '$.key2') as key2 from table1;
```
make array
```{sql}
select id,json_array(id,id/10,id/100) as array from table1;
```
```{sql}
drop table table1;
```

### use jsonb to fasten process
```{r}
dbExecute(con,
          "create temp table table1 (id int, json text)")
data=c("{'key1':1,'key2':10,'key3':{'key31':101,'key32':102,'key33':'aaa'}}",
       "{'key1':2,'key2':20,'key3':{'key31':201,'key33':'bbb'}}",
       "{'key1':3,'key3':{'key31':301,'key33':'ccc'}}")

dbExecute(con,
          paste0('insert into table1 (id, json) values ',
                 '(1, jsonb("',data[1],'")),',
                 '(2, jsonb("',data[2],'")),',
                 '(3, jsonb("',data[3],'"))'))
```

read
```{sql}
select id
, json
, json(json)
, jsonb_extract(json, '$.key1') as key1
, jsonb_extract(json, '$.key2') as key2
, jsonb_extract(json, '$.key3') as key3
from table1;
```

```{sql}
drop table table1;
```



## full text search
```{r}
tb=tribble(~id,~txt1,~txt2,
           1,"Actions speak louder than words.","What you do has more impact than what you say.",
           2,"What goes around, comes around.","Your actions, good or bad, will eventually come back to affect you.",
           3,"A stitch in time saves nine.","Taking timely action prevents bigger problems later.",
           4,"When in Rome, do as the Romans do.","Adapt to the customs and behaviors of the place or culture you are in.",
           5,"You can’t have your cake and eat it too.","You can’t enjoy two contradictory benefits at the same time.",
           6,"Better late than never.","It’s better to do something late than not at all.",
           7,"Don’t put all your eggs in one basket.","Diversify your efforts or investments to reduce risk.",
           8,"The grass is always greener on the other side.","People often think others have it better, even when it’s not true.",
           9,"Many hands make light work.","Tasks are easier to accomplish when many people work together.",
           10,"It’s no use crying over spilled milk.","Don’t waste time worrying about things that cannot be changed.")

dbWriteTable(con,'table1',tb)
dbReadTable(con,'table1')
```

```{sql}
create virtual table vrt1 using fts5 (id,txt1,txt2);
```
```{sql}
insert into vrt1 (id,txt1,txt2)
  select * from table1;
```

```{sql}
select * from vrt1 where vrt1 match 'you';
```

```{sql}
select *
, rank --bm25(vrt1)
from vrt1 where vrt1 match 'you'
order by rank;
```

```{sql}
select *
, rank --bm25(vrt1)
from vrt1 where vrt1 match 'you' or vrt1 match 'better'
order by rank;
```

```
1. What is BM25?

BM25 (Best Matching 25) is a widely-used ranking algorithm in information retrieval. Key features include:

    Higher scores for more relevant documents.
    Based on term frequency (TF) and inverse document frequency (IDF).
    Adjusts for document length to ensure fairness.

In SQLite, BM25 scores are accessible via the FTS5 module when performing full-text searches.

2. Setting Up BM25 in SQLite
(1) Enable the FTS5 Module

First, create a virtual table using the FTS5 module:

CREATE VIRTUAL TABLE documents USING fts5(content);

Here, documents is the virtual table name, and content is the column for storing text data.
(2) Insert Data

Insert some text data into the table:

INSERT INTO documents (content) VALUES
('SQLite is a C library that provides a lightweight database engine.'),
('SQLite supports full-text search using the FTS5 module.'),
('BM25 is a ranking function used by search engines.');

(3) Perform a Search

Run a query using the bm25() function to calculate relevance scores for the results:

SELECT content, bm25(documents) AS score
FROM documents
WHERE documents MATCH 'SQLite'
ORDER BY score;

3. How to Interpret BM25 Scores
Example Output

The result of the above query might look like this:
content	score
SQLite supports full-text search using the FTS5 module.	0.22314355
SQLite is a C library that provides a lightweight database engine.	0.10536052
Score Explanation

    Lower scores indicate higher relevance.
    In SQLite's implementation of BM25, smaller scores mean the document is more relevant to the search query.

    Factors affecting scores:
        Frequency of the search term in the document (higher frequency = higher relevance).
        Document length (shorter documents are favored).
        Overall term rarity across all documents (rare terms have more weight).

4. Customizing BM25 in SQLite

SQLite allows you to adjust the weighting of columns and scoring behavior:
Adjusting Column Weights

You can specify different weights for columns in the FTS5 table. For example:

CREATE VIRTUAL TABLE documents USING fts5(content, title, bm25_weights=1.0, 2.0);

In this case:

    content column has a weight of 1.0.
    title column has a weight of 2.0, making matches in the title more impactful.

5. Practical Examples
Search for Multiple Terms

You can perform searches with multiple terms and retrieve scores:

SELECT content, bm25(documents) AS score
FROM documents
WHERE documents MATCH 'SQLite database'
ORDER BY score;
```

```{sql}
drop table table1;
```
